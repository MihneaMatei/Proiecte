	Prezentare generala
	Circuitul creat simuleaza aruncarea dintr-un elicopter a unui container de provizii pentru niste soldati aflati pe campul de batalie. Circuitul consta in 4 module: un modul ce are ca scop citirea inaltimii de la sol prin 4 senzori a elicopterului si calculul inaltimii medii citite, un modul ce calculeaza, cu ajutorul unei prelucrari intermediare, timpul necesar ajungerii pe sol a containerului, un modul ce verifica posibilitatea de aruncare a containerului si afisarea mesajului corespunzator si un modul ce instantiaza si cuprinde cele 3 module prezentate anterior.

	Modulul 1 – sensors_input
	Acest modul contine informatii cu privire la cei 4 senzori aflati pe burta elicopterului (porturi de input) si un port de output ce contine media acestora. Pentru functionarea acestui modul am ales sa lucrez in interiorul blocului always cu o variabila auxiliara cu dimensiune mai mare decat cea a portului de output, deoarece suma ce va fi stocata la un moment dat in aceasta este posibil sa depaseasca dimensiunea mediei aritmetice. 
	In interiorul blocului always, dupa initializarea variabile mai sus mentionate, vom verifica pe rand conditiile pentru calculul mediei, respectiv existenta unei valori nule in cadrul vreunei perechi de senzori.
	In cadrul fiecarei verificari, vom stabili daca suma va trebui incrementata cu 1 sau cu 2, in functie de ultimii doi biti ai acesteia, pentru a putea rotunji prin adaos media (la rularea programului s-a constatat ca se rotunjeste prin scadere chiar si la o valoare zecimala de .75). Astfel, in cazul excluderii unei perechi de senzori, se verifica daca suma este reprezentata de un numar impar, iar in caz afirmativ se adauga o unitate la suma, iar in cazul in care ambele perechi sunt valabile, se verifica daca restul impartirii la 4 va fi 2 (.5) sau 3(.75) si se adauga 1 sau, respectiv, 2.
	Valoarea stocata in variabila auxiliara, ce va contine media, este asignata la final in variabila de output.

	Modulul 2 – square_root
	In implentarea modului pentru calculul radacinii patrate am ales algoritmul CORDIC. Algoritmul se bazeaza pe raspunsul cu da si nu la verificare: daca rezultatul la patrat depaseste sau nu intrarea.
	Se declara o variabila numita baza, ce are rolul de a fi adunata sau nu la rezultat, iar la finalul fiecarui ciclu for va fi shiftata la dreapta cu puterea 1 a lui 2 (impartita la 2). Baza va fi initializata in blocul always cu 2 la puterea dimensiune output minus 1. Mai declar si o variabila y, de dimensiunea outputului ce va contine rezultatele intermediare si inca o variabila in2, al carei rol este sa contina valoarea inputului shiftata la stanga de 2 * nr de biti cu care vrem sa fie shiftat rezultatul final, in cazul de fata 8, deci 2 * 8.
	In interiorul blocului always, dupa initializarea acestor variabile, incepe algoritmul CORDIC. La fiecare iteratie, baza se aduna rezultatului preliminar. Daca acesta la patrat depaseste intrarea, inseamna ca baza este prea mare si se scade. La finalul fiecarei iteratii baza este impartita la 2, astfel ca rezultatul final este aflat din aproape in aproape.
	La final, valoarea aflata in variabila coresp. rezultatului preliminar este asignata variabilei de output.

	Modulul 3 – display_and_drop
	Pentru functionarea acestui modul am ales sa folosesc variabile auxiliare pentru stocarea valorilor din cei 4 7-seg si o variabila pentru output-ul drop. In interiorul blocului always, se initializeaza variabila auxiliara pentru drop cu 0, deoarece in 3 din 4 cazuri aceasta ramane 0, si se verifica fiecare conditie pentru diferitele afisaje, in functie de t_act, t_lim si drop_en. Pentru fiecare caz se atribuie segmentelor display valorile in binar aferente textului, iar la finalul modulului se asigneaza valorile intermediare in variabilele de output.

	Modulul 4 (top) – baggage_drop
	Modulul top are rolul de a face conexiunile intre celelalte 3 module si de a le instantia. In acest modul, am ales sa folosesc 3 variabile tip wire pentru conexiuni: o variabila pentru inaltime (un ‘capat’ al firului este out-ul modulului 1, iar celalalt ‘capat’ este inputul modulului 2), o variabila pentru radacina (output modul 2 si input prelucrare intermediara) si o variabila pentru t_act (output prelucrare intermediara, input modul 3).
	Se instantiaza modulele 1 si 2, se efectueaza prelucrarea intermediara a radacinii pentru a obtine variabila t_act si se instantiaza modulul 3.
